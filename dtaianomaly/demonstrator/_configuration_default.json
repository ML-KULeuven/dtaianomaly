{
    "data-loader": {
        "default": "DemonstrationTimeSeriesLoader",
        "exclude": []
    },
    "detector": {
        "default": "IsolationForest",
        "exclude": [
            "MultivariateDetector",
            "AlwaysNormal",
            "AlwaysAnomalous",
            "RandomDetector"
        ],
        "parameters": {
            "required": {
                "window_size": 64,
                "neighborhood_size_before": 64
            },
            "optional": {
                "window_size": {
                    "label": "Manual window size",
                    "type": "number_input",
                    "min_value": 1,
                    "step": 1,
                    "value": 64,
                    "help": "The manually-set size of the sliding window."
                },
                "stride": {
                    "label": "Stride",
                    "type": "number_input",
                    "min_value": 1,
                    "step": 1,
                    "value": 1,
                    "help": "The stride of a sliding window is the number of steps the window moves forward each time."
                },
                "start_level": {

                },
                "quantile_boundary_type": {

                },
                "quantile_epsilon": {

                },
                "padding_mode": {

                },
                "sequence_length_multiplier": {

                },
                "overlap_rate": {

                },
                "normalize": {

                },
                "p": {

                },
                "k": {

                },
                "novelty": {

                },
                "neighborhood_size_before": {

                },
                "neighborhood_size_after": {

                },
                "seed": {

                },
                "max_iter": {

                }
            },
            "window_size_selection": {
                "label": "Window size",
                "options": [
                    ["Manual", "Manual"],
                    ["Dominant Fourier Frequency", "fft"],
                    ["Highest Autocorrelation", "acf"],
                    ["Summary Statistics Subsequence", "suss"],
                    ["Multi-Window-Finder", "mwf"]
                ],
                "help": "The used method for setting the window size. Options are:\n\n- **Manual:** Manually set the window size to a specific size.\n- **Dominant Fourier Frequency:** Use the window size which corresponds to the dominant frequency in the Fourier domain.\n- **Highest Autocorrelation:** Use the window size which corresponds to maximum autocorrelation.\n- **Summary Statistics Subsequence:** Find a window size such that the statics of that window are similar to those of the full time series. \n- **Multi-Window-Finder:** Find a window size such that the moving average is small. "
            }
        }
    },
    "metric": {
        "default": [
            "FBeta",
            "AreaUnderROC",
            "VolumeUnderROC"
        ],
        "exclude": [
            "BestThresholdMetric",
            "ThresholdMetric"
        ],
        "parameters": {
            "default_threshold": 0.9,
            "required": {},
            "optional": {
                "cutoff": {
                    "type": "slider",
                    "label": "Cutoff",
                    "help": "The cutoff for converting the anomaly scores to a binary prediction. The cutoff is done on the predicted anomaly scores after min-max scaling.",
                    "min_value": 0.0,
                    "max_value": 1.0,
                    "step": 0.01,
                    "value": 0.9
                },
                "beta": {
                    "type": "number_input",
                    "label": "Beta",
                    "min_value": 0.0,
                    "step": 0.01,
                    "value": 1.0,
                    "help": "Determines the weight of recall in the combined score."
                },
                "buffer_size": {
                    "type": "number_input",
                    "label": "Buffer size",
                    "min_value": 1,
                    "step": 1,
                    "value": 100,
                    "help": "Size of the buffer region around an anomaly. Half of the buffer added before the anomalous event and half of the buffer is added after the anomaly."
                },
                "compatibility_mode": {
                    "type": "toggle",
                    "label": "Use original version",
                    "value": false,
                    "help": "Whether to use the originally proposed version of this metric or the implementation of TimeEval:\n- For the recall (FPR) existence reward, anomalies are counted as separate events, even if the added slopes overlap;\n- Overlapping slopes don't sum up in their anomaly weight, the anomaly weight for each point in the ground truth is maximized;\n- The original slopes are asymmetric: the slopes at the end of anomalies are a single point shorter than the ones at the beginning of anomalies. Symmetric slopes are used, with the same size for the beginning and end of anomalies;\n- A linear approximation of the slopes is used instead of the convex slope shape presented in the paper."
                },
                "max_samples": {
                    "type": "number_input",
                    "label": "Maximum number of thresholds",
                    "value": 100,
                    "min_value": 1,
                    "step": 1,
                    "help": "The number of thresholds to put on the anomaly scores. This offers a trade-off between exactness of the metric and computation time."
                },
                "alpha": {
                    "type": "slider",
                    "label": "Alpha",
                    "min_value": 0.0,
                    "max_value": 1.0,
                    "value": 0.5,
                    "step": 0.01,
                    "help": "The importance of detecting the events (even if it is only a single detected point) compared to detecting a large portion of the ground truth events."
                },
                "delta": {
                    "type": "selectbox",
                    "label": "Delta",
                    "options": [
                        "flat",
                        "front",
                        "back",
                        "middle"
                    ],
                    "index": 0,
                    "help": "Bias for the position of the predicted anomaly in the ground truth anomalous range:\n- **flat:** Equal bias towards all positions in the ground truth anomalous range.\n- **front:** Predictions that are near the front of the ground truth anomaly (i.e. early detection) have a higher weight.\n- **back:** Predictions that are near the end of the ground truth anomaly (i.e. late detection) have a higher weight.\n- **middle:** Predictions that are near the center of the ground truth anomaly have a higher weight.\n"
                },
                "gamma": {
                    "type": "selectbox",
                    "label": "Gamma",
                    "options": [
                        "one",
                        "reciprocal"
                    ],
                    "index": 0,
                    "help": "Penalization approach for detecting multiple ranges with a single range: - **one:** Fragmented detection should not be penalized.\n- **reciprocal:** Weight fragmented detection of $N$ ranges with as single range by a factor of $1/N$."
                },
                "max_buffer_size": {
                    "type": "number_input",
                    "label": "Maximum buffer size",
                    "min_value": 1,
                    "step": 1,
                    "value": 250,
                    "help": "Maximum size of the buffer region around an anomaly. Half of the buffer added before the anomalous event and half of the buffer is added after the anomaly. The metric iterates over all the buffer sizes to to create a volume."
                }
            }
        }
    }
}