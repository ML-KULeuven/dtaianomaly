{

    "data-loader": {
        "default": "DemonstrationTimeSeriesLoader",
        "exclude": []
    },
    "detector": {
        "default": "IsolationForest",
        "exclude": [
            "MultivariateDetector",
            "AlwaysNormal",
            "AlwaysAnomalous",
            "RandomDetector"
        ],
        "parameters": {
            "required": {
                "window_size": 64,
                "neighborhood_size_before": 64
            },
            "optional": {
                "window_size": {
                    "label": "Manual window size",
                    "type": "number_input",
                    "min_value": 1,
                    "step": 1,
                    "value": 64,
                    "help": "The manually-set size of the sliding window."
                },
                "stride": {
                    "label": "Stride",
                    "type": "number_input",
                    "min_value": 1,
                    "step": 1,
                    "value": 1,
                    "help": "The stride of a sliding window is the number of steps the window moves forward each time."
                },
                "start_level": {
                    "type": "number_input",
                    "label": "Start level",
                    "min_value": 0,
                    "value": 3,
                    "step": 1,
                    "help": "The first level for computing the Discrete Wavelet Transform."
                },
                "quantile_epsilon": {
                    "type": "slider",
                    "label": "Quantile",
                    "min_value": 0.0,
                    "max_value": 1.0,
                    "step": 0.01,
                    "value": 0.01,
                    "help": "The percentile used as threshold on the likelihood estimates."
                },
                "padding_mode": {
                    "type": "selectbox",
                    "label": "Padding",
                    "options": [
                        "wrap",
                        "symmetric"
                    ],
                    "index": 0,
                    "help": "How the time series is padded:\n-**wrap:** Use the first values to pad at the end and the last values to pad at the beginning.\n- **symmetric:** Pads with the reflection of the time series."
                },
                "sequence_length_multiplier": {
                    "type": "number_input",
                    "label": "Sequence length multiplier",
                    "min_value": 1,
                    "value": 4,
                    "step": 0.1,
                    "help": "The amount by which the window size should be multiplied to create sliding windows for clustering the data using KShape."
                },
                "overlap_rate": {
                    "type": "slider",
                    "label": "Overlap rate",
                    "min_value": 0.01,
                    "max_value": 1.0,
                    "step": 0.01,
                    "value": 0.5,
                    "help": "The overlap of the sliding windows for clustering the data. Will be used to compute a relative stride to avoid trivial matches when clustering subsequences."
                },
                "normalize": {
                    "type": "toggle",
                    "label": "Z-scale",
                    "value": true,
                    "help": "Whether to Z-scale the time series."
                },
                "p": {
                    "type": "number_input",
                    "label": "Norm",
                    "min_value": 1.0,
                    "value": 2.0,
                    "step": 0.1,
                    "help": "The used norm for computing the distances with the matrix profile."

                },
                "k": {
                    "type": "number_input",
                    "label": "K",
                    "min_value": 1,
                    "value": 1,
                    "step": 1,
                    "help": "Use the distance to the K-th nearest neighbor as an anomaly score."
                },
                "novelty": {
                    "type": "toggle",
                    "label": "Novelty detection",
                    "value": false,
                    "help": "If novelty detection should be performed, i.e., detect anomalies with regards to a normal time series."
                },
                "neighborhood_size_before": {
                    "type": "number_input",
                    "label": "Neighborhood size before the sample",
                    "min_value": 1,
                    "value": 64,
                    "step": 1,
                    "help": "The number of observations before the sample to include in the neighborhood."
                },
                "neighborhood_size_after": {
                    "type": "number_input",
                    "label": "Neighborhood size after the sample",
                    "min_value": 0,
                    "value": null,
                    "step": 1,
                    "help": "The number of observations after the sample to include in the neighborhood. If no value is given, the neighborhood size after the window will be set to the same value as the neighborhood size before the window."
                },
                "seed": {
                    "type": "number_input",
                    "label": "Seed",
                    "min_value": 1,
                    "value": null,
                    "step": 1,
                    "help": "The random seed to set."
                },
                "max_iter": {
                    "type": "number_input",
                    "label": "Maximum number of iterations",
                    "min_value": 1,
                    "value": 1000,
                    "step": 1,
                    "help": "The maximum number of iterations to perform during optimization."
                }
            },
            "window_size_selection": {
                "label": "Window size",
                "options": [
                    ["Manual", "Manual"],
                    ["Dominant Fourier Frequency", "fft"],
                    ["Highest Autocorrelation", "acf"],
                    ["Summary Statistics Subsequence", "suss"],
                    ["Multi-Window-Finder", "mwf"]
                ],
                "help": "The used method for setting the window size. Options are:\n\n- **Manual:** Manually set the window size to a specific size.\n- **Dominant Fourier Frequency:** Use the window size which corresponds to the dominant frequency in the Fourier domain.\n- **Highest Autocorrelation:** Use the window size which corresponds to maximum autocorrelation.\n- **Summary Statistics Subsequence:** Find a window size such that the statics of that window are similar to those of the full time series. \n- **Multi-Window-Finder:** Find a window size such that the moving average is small. "
            }
        }
    },
    "metric": {
        "default": [
            "FBeta",
            "AreaUnderROC",
            "VolumeUnderROC"
        ],
        "exclude": [
            "BestThresholdMetric",
            "ThresholdMetric"
        ],
        "parameters": {
            "default_threshold": 0.9,
            "required": {},
            "optional": {
                "cutoff": {
                    "type": "slider",
                    "label": "Cutoff",
                    "help": "The cutoff for converting the anomaly scores to a binary prediction. The cutoff is done on the predicted anomaly scores after min-max scaling.",
                    "min_value": 0.0,
                    "max_value": 1.0,
                    "step": 0.01,
                    "value": 0.9
                },
                "beta": {
                    "type": "number_input",
                    "label": "Beta",
                    "min_value": 0.0,
                    "step": 0.01,
                    "value": 1.0,
                    "help": "Determines the weight of recall in the combined score."
                },
                "buffer_size": {
                    "type": "number_input",
                    "label": "Buffer size",
                    "min_value": 1,
                    "step": 1,
                    "value": 100,
                    "help": "Size of the buffer region around an anomaly. Half of the buffer added before the anomalous event and half of the buffer is added after the anomaly."
                },
                "compatibility_mode": {
                    "type": "toggle",
                    "label": "Use original version",
                    "value": false,
                    "help": "Whether to use the originally proposed version of this metric or the implementation of TimeEval:\n- For the recall (FPR) existence reward, anomalies are counted as separate events, even if the added slopes overlap;\n- Overlapping slopes don't sum up in their anomaly weight, the anomaly weight for each point in the ground truth is maximized;\n- The original slopes are asymmetric: the slopes at the end of anomalies are a single point shorter than the ones at the beginning of anomalies. Symmetric slopes are used, with the same size for the beginning and end of anomalies;\n- A linear approximation of the slopes is used instead of the convex slope shape presented in the paper."
                },
                "max_samples": {
                    "type": "number_input",
                    "label": "Maximum number of thresholds",
                    "value": 100,
                    "min_value": 1,
                    "step": 1,
                    "help": "The number of thresholds to put on the anomaly scores. This offers a trade-off between exactness of the metric and computation time."
                },
                "alpha": {
                    "type": "slider",
                    "label": "Alpha",
                    "min_value": 0.0,
                    "max_value": 1.0,
                    "value": 0.5,
                    "step": 0.01,
                    "help": "The importance of detecting the events (even if it is only a single detected point) compared to detecting a large portion of the ground truth events."
                },
                "delta": {
                    "type": "selectbox",
                    "label": "Delta",
                    "options": [
                        "flat",
                        "front",
                        "back",
                        "middle"
                    ],
                    "index": 0,
                    "help": "Bias for the position of the predicted anomaly in the ground truth anomalous range:\n- **flat:** Equal bias towards all positions in the ground truth anomalous range.\n- **front:** Predictions that are near the front of the ground truth anomaly (i.e. early detection) have a higher weight.\n- **back:** Predictions that are near the end of the ground truth anomaly (i.e. late detection) have a higher weight.\n- **middle:** Predictions that are near the center of the ground truth anomaly have a higher weight.\n"
                },
                "gamma": {
                    "type": "selectbox",
                    "label": "Gamma",
                    "options": [
                        "one",
                        "reciprocal"
                    ],
                    "index": 0,
                    "help": "Penalization approach for detecting multiple ranges with a single range: - **one:** Fragmented detection should not be penalized.\n- **reciprocal:** Weight fragmented detection of $N$ ranges with as single range by a factor of $1/N$."
                },
                "max_buffer_size": {
                    "type": "number_input",
                    "label": "Maximum buffer size",
                    "min_value": 1,
                    "step": 1,
                    "value": 250,
                    "help": "Maximum size of the buffer region around an anomaly. Half of the buffer added before the anomalous event and half of the buffer is added after the anomaly. The metric iterates over all the buffer sizes to to create a volume."
                }
            }
        }
    }
}